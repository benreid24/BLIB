<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BLIB: bl::container::ObjectPool&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BLIB
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">Ben&#39;s SFML Game Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a00961.html">bl</a></li><li class="navelem"><a class="el" href="a00964.html">container</a></li><li class="navelem"><a class="el" href="a01070.html">ObjectPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="a01067.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">bl::container::ObjectPool&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="a00933.html">Containers</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Basic object pool that may vary in size. Similar to <a class="el" href="a01058.html" title="A thin reskin of std::vector, this vector replaces the O(n) erase() methods of vector with a constant...">FastEraseVector</a> in that erase is O(1), however objects in the pool maintain their indices in the <a class="el" href="a01070.html" title="Basic object pool that may vary in size. Similar to FastEraseVector in that erase is O(1)...">ObjectPool</a>. Object slots are marked free on <a class="el" href="a01070.html#ab442aaa73233ff5659c828b7cfc9d228" title="Removes the given iterator from the pool and marks the object slot for resuse. All iterators remain v...">erase()</a>, reused on <a class="el" href="a01070.html#a058a31d48e47bf82c5739ba9f83234b0" title="Adds the given object to the pool. Either reuses an empty object slot or expands the pool if no empty...">add()</a>, and the pool grows in size if no slot is when <a class="el" href="a01070.html#a058a31d48e47bf82c5739ba9f83234b0" title="Adds the given object to the pool. Either reuses an empty object slot or expands the pool if no empty...">add()</a> is called. Objects must implement a default constructor and copy constructor.  
 <a href="a01070.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00032_source.html">ObjectPool.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01074.html">IteratorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for traversing the object pool. Use Iterator or ConstIterator. Forward iteration only.  <a href="a01074.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8f3ba1866f0d59f4c59a71baf65e6a2e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a8f3ba1866f0d59f4c59a71baf65e6a2e">GrowthPolicy</a> { <a class="el" href="a01070.html#a8f3ba1866f0d59f4c59a71baf65e6a2ea55d57684e37853782141c970a4df7b3f">GrowthPolicy::ExpandBuffer</a>, 
<a class="el" href="a01070.html#a8f3ba1866f0d59f4c59a71baf65e6a2ea397f2ef02361db55ac809f6e79ce5c0f">GrowthPolicy::FailContinue</a>, 
<a class="el" href="a01070.html#a8f3ba1866f0d59f4c59a71baf65e6a2ea8614c7df46beb12646183fa39e23a92a">GrowthPolicy::FailTerminate</a>
 }<tr class="memdesc:a8f3ba1866f0d59f4c59a71baf65e6a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy which dictates how the pool handles adding new objects when it is full.  <a href="a01070.html#a8f3ba1866f0d59f4c59a71baf65e6a2e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8f3ba1866f0d59f4c59a71baf65e6a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb826650489fc0e7a1d89885edb71f61"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a> = <a class="el" href="a01074.html">IteratorType</a>&lt; T &gt;</td></tr>
<tr class="separator:afb826650489fc0e7a1d89885edb71f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d85368a1aa704a4bbbca444685cc25"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#aa2d85368a1aa704a4bbbca444685cc25">ConstIterator</a> = <a class="el" href="a01074.html">IteratorType</a>&lt; const T &gt;</td></tr>
<tr class="separator:aa2d85368a1aa704a4bbbca444685cc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a27f9907a3e436ee0dafc7153f6aaabc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a27f9907a3e436ee0dafc7153f6aaabc9">ObjectPool</a> (<a class="el" href="a01070.html#a8f3ba1866f0d59f4c59a71baf65e6a2e">GrowthPolicy</a> policy, std::size_t <a class="el" href="a01070.html#ac8bfa220ebcf3a7749984d1856556006">capacity</a>)</td></tr>
<tr class="memdesc:a27f9907a3e436ee0dafc7153f6aaabc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the object pool with the growth policy and initial capacity. Not that, unless the growth policy is ExpandBuffer, the pool capacity will always be the given capacity.  <a href="#a27f9907a3e436ee0dafc7153f6aaabc9">More...</a><br /></td></tr>
<tr class="separator:a27f9907a3e436ee0dafc7153f6aaabc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058a31d48e47bf82c5739ba9f83234b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a058a31d48e47bf82c5739ba9f83234b0">add</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:a058a31d48e47bf82c5739ba9f83234b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given object to the pool. Either reuses an empty object slot or expands the pool if no empty slots. All iterators remain valid.  <a href="#a058a31d48e47bf82c5739ba9f83234b0">More...</a><br /></td></tr>
<tr class="separator:a058a31d48e47bf82c5739ba9f83234b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cac0543c27daab2bdb6ad94da2cc8d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a0cac0543c27daab2bdb6ad94da2cc8d6">add</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:a0cac0543c27daab2bdb6ad94da2cc8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the given object to the pool. Either reuses an empty object slot or expands the pool if no empty slots. All iterators remain valid.  <a href="#a0cac0543c27daab2bdb6ad94da2cc8d6">More...</a><br /></td></tr>
<tr class="separator:a0cac0543c27daab2bdb6ad94da2cc8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85eaf70662f200632cd6b7898a9522b"><td class="memTemplParams" colspan="2">template&lt;typename... TArgs&gt; </td></tr>
<tr class="memitem:ab85eaf70662f200632cd6b7898a9522b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a01070.html#ab85eaf70662f200632cd6b7898a9522b">emplace</a> (TArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab85eaf70662f200632cd6b7898a9522b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new object inplace in the pool.  <a href="#ab85eaf70662f200632cd6b7898a9522b">More...</a><br /></td></tr>
<tr class="separator:ab85eaf70662f200632cd6b7898a9522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab442aaa73233ff5659c828b7cfc9d228"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#ab442aaa73233ff5659c828b7cfc9d228">erase</a> (const <a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a> &amp;i)</td></tr>
<tr class="memdesc:ab442aaa73233ff5659c828b7cfc9d228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given iterator from the pool and marks the object slot for resuse. All iterators remain valid except for the one removed. The erased iterator is partially invalidated. It may not be dereferenced but it may still be incremented.  <a href="#ab442aaa73233ff5659c828b7cfc9d228">More...</a><br /></td></tr>
<tr class="separator:ab442aaa73233ff5659c828b7cfc9d228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6ccb7e23f8cc309947bfb973b99346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a9c6ccb7e23f8cc309947bfb973b99346">begin</a> ()</td></tr>
<tr class="memdesc:a9c6ccb7e23f8cc309947bfb973b99346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the beginning of the pool.  <a href="#a9c6ccb7e23f8cc309947bfb973b99346">More...</a><br /></td></tr>
<tr class="separator:a9c6ccb7e23f8cc309947bfb973b99346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88838fb6e4d2a0e6896c90d55ddd8be6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01070.html#aa2d85368a1aa704a4bbbca444685cc25">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a88838fb6e4d2a0e6896c90d55ddd8be6">begin</a> () const</td></tr>
<tr class="memdesc:a88838fb6e4d2a0e6896c90d55ddd8be6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the beginning of the pool.  <a href="#a88838fb6e4d2a0e6896c90d55ddd8be6">More...</a><br /></td></tr>
<tr class="separator:a88838fb6e4d2a0e6896c90d55ddd8be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a04d62d279882817065d190ff55230"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a42a04d62d279882817065d190ff55230">end</a> ()</td></tr>
<tr class="memdesc:a42a04d62d279882817065d190ff55230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the end of the pool.  <a href="#a42a04d62d279882817065d190ff55230">More...</a><br /></td></tr>
<tr class="separator:a42a04d62d279882817065d190ff55230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1870988cd138cfa2f727bc015116c007"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a01070.html#aa2d85368a1aa704a4bbbca444685cc25">ConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a1870988cd138cfa2f727bc015116c007">end</a> () const</td></tr>
<tr class="memdesc:a1870988cd138cfa2f727bc015116c007"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a const iterator to the end of the pool.  <a href="#a1870988cd138cfa2f727bc015116c007">More...</a><br /></td></tr>
<tr class="separator:a1870988cd138cfa2f727bc015116c007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7eba214d944c400844c1be0f0abbc6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#adb7eba214d944c400844c1be0f0abbc6">size</a> () const</td></tr>
<tr class="memdesc:adb7eba214d944c400844c1be0f0abbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the pool.  <a href="#adb7eba214d944c400844c1be0f0abbc6">More...</a><br /></td></tr>
<tr class="separator:adb7eba214d944c400844c1be0f0abbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bfa220ebcf3a7749984d1856556006"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#ac8bfa220ebcf3a7749984d1856556006">capacity</a> () const</td></tr>
<tr class="memdesc:ac8bfa220ebcf3a7749984d1856556006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the capacity of the pool. This is the size plus the amount of unused slots.  <a href="#ac8bfa220ebcf3a7749984d1856556006">More...</a><br /></td></tr>
<tr class="separator:ac8bfa220ebcf3a7749984d1856556006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484ef929991d71701f01893f3afc57d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a484ef929991d71701f01893f3afc57d2">reserve</a> (std::size_t <a class="el" href="a01070.html#ac8bfa220ebcf3a7749984d1856556006">capacity</a>)</td></tr>
<tr class="memdesc:a484ef929991d71701f01893f3afc57d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space for the given capacity.  <a href="#a484ef929991d71701f01893f3afc57d2">More...</a><br /></td></tr>
<tr class="separator:a484ef929991d71701f01893f3afc57d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da36709ef36559eb01b00879b1c03db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a0da36709ef36559eb01b00879b1c03db">clear</a> (bool shrinkStorage=false)</td></tr>
<tr class="memdesc:a0da36709ef36559eb01b00879b1c03db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all objects from the pool. This invalidates all iterators.  <a href="#a0da36709ef36559eb01b00879b1c03db">More...</a><br /></td></tr>
<tr class="separator:a0da36709ef36559eb01b00879b1c03db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38989822ec7a0ff888b213b3d422c862"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a38989822ec7a0ff888b213b3d422c862">shrink</a> ()</td></tr>
<tr class="memdesc:a38989822ec7a0ff888b213b3d422c862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks the capacity of the pool down to the size.  <a href="#a38989822ec7a0ff888b213b3d422c862">More...</a><br /></td></tr>
<tr class="separator:a38989822ec7a0ff888b213b3d422c862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efe5acd0011ff861c7749ccf5efe0ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01070.html#a7efe5acd0011ff861c7749ccf5efe0ab">empty</a> () const</td></tr>
<tr class="memdesc:a7efe5acd0011ff861c7749ccf5efe0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the pool is empty.  <a href="#a7efe5acd0011ff861c7749ccf5efe0ab">More...</a><br /></td></tr>
<tr class="separator:a7efe5acd0011ff861c7749ccf5efe0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class bl::container::ObjectPool&lt; T &gt;</h3>

<p>Basic object pool that may vary in size. Similar to <a class="el" href="a01058.html" title="A thin reskin of std::vector, this vector replaces the O(n) erase() methods of vector with a constant...">FastEraseVector</a> in that erase is O(1), however objects in the pool maintain their indices in the <a class="el" href="a01070.html" title="Basic object pool that may vary in size. Similar to FastEraseVector in that erase is O(1)...">ObjectPool</a>. Object slots are marked free on <a class="el" href="a01070.html#ab442aaa73233ff5659c828b7cfc9d228" title="Removes the given iterator from the pool and marks the object slot for resuse. All iterators remain v...">erase()</a>, reused on <a class="el" href="a01070.html#a058a31d48e47bf82c5739ba9f83234b0" title="Adds the given object to the pool. Either reuses an empty object slot or expands the pool if no empty...">add()</a>, and the pool grows in size if no slot is when <a class="el" href="a01070.html#a058a31d48e47bf82c5739ba9f83234b0" title="Adds the given object to the pool. Either reuses an empty object slot or expands the pool if no empty...">add()</a> is called. Objects must implement a default constructor and copy constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of object to store. Works best with small POD objects </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00025">25</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aa2d85368a1aa704a4bbbca444685cc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d85368a1aa704a4bbbca444685cc25">&#9670;&nbsp;</a></span>ConstIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::<a class="el" href="a01070.html#aa2d85368a1aa704a4bbbca444685cc25">ConstIterator</a> =  <a class="el" href="a01074.html">IteratorType</a>&lt;const T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00128">128</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="afb826650489fc0e7a1d89885edb71f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb826650489fc0e7a1d89885edb71f61">&#9670;&nbsp;</a></span>Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::<a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a> =  <a class="el" href="a01074.html">IteratorType</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00127">127</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a8f3ba1866f0d59f4c59a71baf65e6a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3ba1866f0d59f4c59a71baf65e6a2e">&#9670;&nbsp;</a></span>GrowthPolicy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a01070.html#a8f3ba1866f0d59f4c59a71baf65e6a2e">bl::container::ObjectPool::GrowthPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Policy which dictates how the pool handles adding new objects when it is full. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8f3ba1866f0d59f4c59a71baf65e6a2ea55d57684e37853782141c970a4df7b3f"></a>ExpandBuffer&#160;</td><td class="fielddoc"><p>The pool is reallocated to a larger buffer. Addresses are not stable. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f3ba1866f0d59f4c59a71baf65e6a2ea397f2ef02361db55ac809f6e79ce5c0f"></a>FailContinue&#160;</td><td class="fielddoc"><p><a class="el" href="a01070.html#a058a31d48e47bf82c5739ba9f83234b0" title="Adds the given object to the pool. Either reuses an empty object slot or expands the pool if no empty...">add()</a> will fail and return <a class="el" href="a01070.html#a42a04d62d279882817065d190ff55230" title="Returns an iterator to the end of the pool. ">end()</a> when the pool is full. Addresses are stable </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f3ba1866f0d59f4c59a71baf65e6a2ea8614c7df46beb12646183fa39e23a92a"></a>FailTerminate&#160;</td><td class="fielddoc"><p><a class="el" href="a01070.html#a058a31d48e47bf82c5739ba9f83234b0" title="Adds the given object to the pool. Either reuses an empty object slot or expands the pool if no empty...">add()</a> will call std::exit() when the pool is full </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00030">30</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a27f9907a3e436ee0dafc7153f6aaabc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f9907a3e436ee0dafc7153f6aaabc9">&#9670;&nbsp;</a></span>ObjectPool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::<a class="el" href="a01070.html">ObjectPool</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a01070.html#a8f3ba1866f0d59f4c59a71baf65e6a2e">GrowthPolicy</a>&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the object pool with the growth policy and initial capacity. Not that, unless the growth policy is ExpandBuffer, the pool capacity will always be the given capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>How to handle <a class="el" href="a01070.html#a058a31d48e47bf82c5739ba9f83234b0" title="Adds the given object to the pool. Either reuses an empty object slot or expands the pool if no empty...">add()</a> when the pool is full </td></tr>
    <tr><td class="paramname">capacity</td><td>The size of buffer to create </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00316">316</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a058a31d48e47bf82c5739ba9f83234b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058a31d48e47bf82c5739ba9f83234b0">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01070.html">ObjectPool</a>&lt; T &gt;::<a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a> <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given object to the pool. Either reuses an empty object slot or expands the pool if no empty slots. All iterators remain valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Object to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator Iterator to the newly created object </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00326">326</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="a0cac0543c27daab2bdb6ad94da2cc8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cac0543c27daab2bdb6ad94da2cc8d6">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01070.html">ObjectPool</a>&lt; T &gt;::<a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a> <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::add </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds the given object to the pool. Either reuses an empty object slot or expands the pool if no empty slots. All iterators remain valid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Object to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator Iterator to the newly created object </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00336">336</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="a9c6ccb7e23f8cc309947bfb973b99346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6ccb7e23f8cc309947bfb973b99346">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01070.html">ObjectPool</a>&lt; T &gt;::<a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a> <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the beginning of the pool. </p>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00398">398</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="a88838fb6e4d2a0e6896c90d55ddd8be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88838fb6e4d2a0e6896c90d55ddd8be6">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01070.html">ObjectPool</a>&lt; T &gt;::<a class="el" href="a01070.html#aa2d85368a1aa704a4bbbca444685cc25">ConstIterator</a> <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the beginning of the pool. </p>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00403">403</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="ac8bfa220ebcf3a7749984d1856556006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bfa220ebcf3a7749984d1856556006">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the capacity of the pool. This is the size plus the amount of unused slots. </p>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00423">423</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="a0da36709ef36559eb01b00879b1c03db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da36709ef36559eb01b00879b1c03db">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shrinkStorage</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all objects from the pool. This invalidates all iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shrinkStorage</td><td>True to also clear the pool's memory, false to leave it </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00438">438</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="ab85eaf70662f200632cd6b7898a9522b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85eaf70662f200632cd6b7898a9522b">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... TArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01070.html">ObjectPool</a>&lt; T &gt;::<a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a> <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a new object inplace in the pool. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TArgs</td><td>The types of arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to construct the new object with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Iterator Iterator to the newly created object </dd></dl>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00347">347</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="a7efe5acd0011ff861c7749ccf5efe0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efe5acd0011ff861c7749ccf5efe0ab">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not the pool is empty. </p>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00433">433</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="a42a04d62d279882817065d190ff55230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a04d62d279882817065d190ff55230">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01070.html">ObjectPool</a>&lt; T &gt;::<a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a> <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterator to the end of the pool. </p>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00408">408</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="a1870988cd138cfa2f727bc015116c007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1870988cd138cfa2f727bc015116c007">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a01070.html">ObjectPool</a>&lt; T &gt;::<a class="el" href="a01070.html#aa2d85368a1aa704a4bbbca444685cc25">ConstIterator</a> <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a const iterator to the end of the pool. </p>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00413">413</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="ab442aaa73233ff5659c828b7cfc9d228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab442aaa73233ff5659c828b7cfc9d228">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a01070.html#afb826650489fc0e7a1d89885edb71f61">Iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the given iterator from the pool and marks the object slot for resuse. All iterators remain valid except for the one removed. The erased iterator is partially invalidated. It may not be dereferenced but it may still be incremented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Iterator to erase </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00389">389</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="a484ef929991d71701f01893f3afc57d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484ef929991d71701f01893f3afc57d2">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve space for the given capacity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The amount of elements to reserve space for </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00428">428</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="a38989822ec7a0ff888b213b3d422c862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38989822ec7a0ff888b213b3d422c862">&#9670;&nbsp;</a></span>shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::shrink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shrinks the capacity of the pool down to the size. </p>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00455">455</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<a id="adb7eba214d944c400844c1be0f0abbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7eba214d944c400844c1be0f0abbc6">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="a01070.html">bl::container::ObjectPool</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of the pool. </p>

<p class="definition">Definition at line <a class="el" href="a00032_source.html#l00418">418</a> of file <a class="el" href="a00032_source.html">ObjectPool.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/BLIB/Containers/<a class="el" href="a00032_source.html">ObjectPool.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 22 2022 21:50:19 for BLIB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
